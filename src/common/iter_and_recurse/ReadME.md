# 迭代与递归

迭代乃人工，递归方神通

## 迭代

### 数组求和

问题：计算任意$`n`$个整数之和

时间复杂度：$`T(n) = 1 + n*1 + 1 = n + 2 = O(n)`$

空间复杂度：$`O(1)`$



## 递归

### 减而治之（Decrease and Concur）

#### 数组求和

为求解一个大规模的问题，可以：将其划分为两个子问题：其一平凡，另一规模缩减，分别求解子问题。由子问题的解，得到原始问题的解。这样的策略就是减而治之。

![图1](../../../assets/common/iter_and_recurse/Snipaste_2024-06-03_22-12-03.png)

**递归跟踪分析**：

检查每个递归实例，累计所需时间（调用语句本身，计入对应的子实例），其总和即算法执行时间

![图2](../../../assets/common/iter_and_recurse/Snipaste_2024-06-03_22-16-26.png)

本例中，单个递归实例自身只需$`O(1)`$，总的时间复杂度为$`T(n) = O(1) * (n + 1) = O(n)`$

从递推的角度看，为求解sum(A,n)，需要递归求解规模为n-1的问题sum(A, n-1)，再加上A[n-1]。递归基：sum(A,0)。

递推方程为：$`T(n) = T(n-1) + O(1)`$, $`T(0) = 1`$。

#### 数组倒置

任意给定数组A[0, n]，将其前后颠倒。

```cpp
void RecurseReverse(int *A, int lo, int hi)
{
    if (hi <= lo) { // O(1)
        return;
    }
    int tmp = A[lo]; // O(1)
    A[lo] = A[hi]; // O(1)
    A[hi] = tmp; // O(1)
    RecurseReverse(A, lo + 1, hi - 1); // T(n-2)
}
```

递推方程：$T(n) = T(n-2) + 4$，$T(0) = 1, T(-1) = 1$